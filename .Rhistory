beta = runif(1, 0.001, 0.01)
tau = runif(1, 10, 15)
iniLongRunRate = runif(1, 0.15, 1)
RLResults = RL(beta, tau, iniLongRunRate, htSeq_)
acceptMatrix_[, ,sIdx] = RLResults$acceptMatrixOnGrid
}
acceptMatrix = apply(acceptMatrix_, MARGIN = c(1,2), FUN = function(x) mean(x, rm.na = T))
dim(acceptMatrix)
# social
tGrid = c(seq(0, blockSec, by = 0.5), seq(0, blockSec, by = 0.5) + blockSec)
nT = length(tGrid)
acceptMatrix_ = array(NA, dim = c(nUnqHt,  nT, nSub))
for(sIdx in 1 : nSub){
beta_self = runif(1, 0.001, 0.01)
beta_other = beta_self
tau = runif(1, 10, 15)
iniLongRunRate = runif(1, 0.15, 1)
RLResults = RLSocial(beta_self, beta_other, tau, iniLongRunRate, htSeq_)
acceptMatrix_[, ,sIdx] = RLResults$acceptMatrixOnGrid
}
acceptMatrix = apply(acceptMatrix_, MARGIN = c(1,2), FUN = function(x) mean(x, rm.na = T))
plotData = data.frame(t(acceptMatrix)); colnames(plotData) =  paste(unqHts); plotData$time = tGrid
socialData = plotData
# combine data from two conditions
aggData = rbind(gather(socialData, key = ht, value = pAccept, -time),
gather(nonSocialData, key = ht, value = pAccept, -time))
aggData$condition = factor(rep(c("social", "non_social"), each = nT * nUnqHt * 2),
levels = c("social", "non_social"))
# calculate the ideal behavior, assuming there is noise in actions
meanTau = mean(c(10, 15))
aggData$optimPAccept = rep(c(rep(1 / (1 + exp(meanTau * (unqHts * optimLongRunRate_[['rich']] - rwd))), each = nT),
rep(1 / (1 + exp(meanTau * (unqHts * optimLongRunRate_[['poor']] - rwd))), each = nT)),
2)
aggData %>% mutate(ht = factor(ht, levels = unqHts)) %>%
ggplot(aes(time, pAccept, color = condition)) + geom_line(size = 1) +
scale_color_manual(values = c("red", "black")) + facet_wrap(~ht) +
geom_line(aes(time, optimPAccept), color = "#353535", linetype = "dashed") +
myTheme + xlab("Time (s)") + ylab("Percentage of accepted trials(%)") +
scale_y_continuous(limits = c(-0.1, 1.1), breaks = c(0, 0.5, 1))
# combine data from two conditions
aggData = rbind(gather(socialData, key = ht, value = pAccept, -time),
gather(nonSocialData, key = ht, value = pAccept, -time))
aggData$condition = factor(rep(c("social", "non_social"), each = nT * nUnqHt * 2),
levels = c("social", "non_social"))
aggData = rbind(gather(socialData, key = ht, value = pAccept, -time),
gather(nonSocialData, key = ht, value = pAccept, -time))
str(aggData)
nT
nT * 4 * 4
nT * 4 * 2
aggData$condition = factor(rep(c("social", "non_social"), each = nT * nUnqHt),
levels = c("social", "non_social"))
meanTau = mean(c(10, 15))
aggData$optimPAccept = rep(c(rep(1 / (1 + exp(meanTau * (unqHts * optimLongRunRate_[['rich']] - rwd))), each = nT / 2),
rep(1 / (1 + exp(meanTau * (unqHts * optimLongRunRate_[['poor']] - rwd))), each = nT / 2)),
2)
aggData %>% mutate(ht = factor(ht, levels = unqHts)) %>%
ggplot(aes(time, pAccept, color = condition)) + geom_line(size = 1) +
scale_color_manual(values = c("red", "black")) + facet_wrap(~ht) +
geom_line(aes(time, optimPAccept), color = "#353535", linetype = "dashed") +
myTheme + xlab("Time (s)") + ylab("Percentage of accepted trials(%)") +
scale_y_continuous(limits = c(-0.1, 1.1), breaks = c(0, 0.5, 1))
1 + exp(meanTau * (unqHts * optimLongRunRate_[['rich']] - rwd)))
1 / (1 + exp(meanTau * (unqHts * optimLongRunRate_[['rich']] - rwd)))
1 + exp(meanTau * (unqHts * optimLongRunRate_[['poor']] - rwd)))
1 / (1 + exp(meanTau * (unqHts * optimLongRunRate_[['poor']] - rwd)))
View(aggData)
unique(aggData$ht)
str(socialData)
str(NonSocialData)
str(nonSocialData)
unqHts
aggData$optimPAccept = rep(
sapply(1 : nUnqHt, function(i) c(rep(1 / (1 + exp(meanTau * (unqHts[i] * optimLongRunRate_[['rich']] - rwd))), nT / 2),
rep(1 / (1 + exp(meanTau * (unqHts[i] * optimLongRunRate_[['poor']] - rwd))))), nT / 2),
2)
calculate the ideal behavior, assuming there is noise in actions
meanTau = mean(c(10, 15))
aggData$optimPAccept = rep(
sapply(1 : nUnqHt, function(i) c(rep(1 / (1 + exp(meanTau * (unqHts[i] * optimLongRunRate_[['rich']] - rwd))), nT / 2),
rep(1 / (1 + exp(meanTau * (unqHts[i] * optimLongRunRate_[['poor']] - rwd)))), nT / 2),
2))
# calculate the ideal behavior, assuming there is noise in actions
meanTau = mean(c(10, 15))
aggData$optimPAccept = rep(
sapply(1 : nUnqHt, function(i) c(rep(1 / (1 + exp(meanTau * (unqHts[i] * optimLongRunRate_[['rich']] - rwd))), nT / 2),
rep(1 / (1 + exp(meanTau * (unqHts[i] * optimLongRunRate_[['poor']] - rwd)))), nT / 2)),
2)
# combine data from two conditions
aggData = rbind(gather(socialData, key = ht, value = pAccept, -time),
gather(nonSocialData, key = ht, value = pAccept, -time))
aggData$condition = factor(rep(c("social", "non_social"), each = nT * nUnqHt),
levels = c("social", "non_social"))
sapply(1 : nUnqHt, function(i) c(rep(1 / (1 + exp(meanTau * (unqHts[i] * optimLongRunRate_[['rich']] - rwd))), nT / 2),
rep(1 / (1 + exp(meanTau * (unqHts[i] * optimLongRunRate_[['poor']] - rwd)))), nT / 2))
meanTau = mean(c(10, 15))
aggData$optimPAccept = rep(
as.vector(sapply(1 : nUnqHt, function(i) c(rep(1 / (1 + exp(meanTau * (unqHts[i] * optimLongRunRate_[['rich']] - rwd))), nT / 2),
rep(1 / (1 + exp(meanTau * (unqHts[i] * optimLongRunRate_[['poor']] - rwd)))), nT / 2))),
2)
# calculate the ideal behavior, assuming there is noise in actions
aggData$optimPAccept = 1 / (1 + exp(meanTau * (aggData$ht * optimLongRunRate_[[aggData$condition]] - rwd)))
aggData %>% mutate(ht = factor(ht, levels = unqHts)) %>%
ggplot(aes(time, pAccept, color = condition)) + geom_line(size = 1) +
scale_color_manual(values = c("red", "black")) + facet_wrap(~ht) +
geom_line(aes(time, optimPAccept), color = "#353535", linetype = "dashed") +
myTheme + xlab("Time (s)") + ylab("Percentage of accepted trials(%)") +
scale_y_continuous(limits = c(-0.1, 1.1), breaks = c(0, 0.5, 1))
# calculate the ideal behavior, assuming there is noise in actions
aggData$optimPAccept = 1 / (1 + exp(meanTau * (aggData$ht * optimLongRunRate_[[aggData$condition]] - rwd)))
optimLongRunRate_[[aggData$condition]]
aggData$condition
optimLongRunRate_[[aggData$condition]]
optimLongRunRate_[aggData$condition]
# calculate the ideal behavior, assuming there is noise in actions
aggData$optimPAccept = 1 / (1 + exp(meanTau * (aggData$ht * as.numeric(optimLongRunRate_[aggData$condition]) - rwd)))
optimLongRunRate_[aggData$condition]
as.numeric(optimLongRunRate_[aggData$condition])
aggData$ht * as.numeric(optimLongRunRate_[aggData$condition]) - rwd
aggData$ht
# calculate the ideal behavior, assuming there is noise in actions
aggData$optimPAccept = 1 / (1 + exp(meanTau * (as.numeric(aggData$ht) * as.numeric(optimLongRunRate_[aggData$condition]) - rwd)))
aggData %>% mutate(ht = factor(ht, levels = unqHts)) %>%
ggplot(aes(time, pAccept, color = condition)) + geom_line(size = 1) +
scale_color_manual(values = c("red", "black")) + facet_wrap(~ht) +
geom_line(aes(time, optimPAccept), color = "#353535", linetype = "dashed") +
myTheme + xlab("Time (s)") + ylab("Percentage of accepted trials(%)") +
scale_y_continuous(limits = c(-0.1, 1.1), breaks = c(0, 0.5, 1))
aggData %>% mutate(ht = factor(ht, levels = unqHts)) %>%
ggplot(aes(time, pAccept, color = condition)) + geom_line(size = 1) +
scale_color_manual(values = c("red", "black")) + facet_wrap(~ht)
1 / (1 + exp(meanTau * (as.numeric(aggData$ht) * as.numeric(optimLongRunRate_[aggData$condition]) - rwd)))
aggData[aggData$time == 0,]
aggData[aggData$time == 605,]
blockSec
aggData$condition
# non_social
tGrid = c(seq(0, blockSec, by = 0.5), seq(0, blockSec, by = 0.5) + blockSec)
nT = length(tGrid)
acceptMatrix_ = array(NA, dim = c(nUnqHt,  nT, nSub))
for(sIdx in 1 : nSub){
beta = runif(1, 0.001, 0.01)
tau = runif(1, 10, 15)
iniLongRunRate = runif(1, 0.15, 1)
RLResults = RL(beta, tau, iniLongRunRate, htSeq_)
acceptMatrix_[, ,sIdx] = RLResults$acceptMatrixOnGrid
}
acceptMatrix = apply(acceptMatrix_, MARGIN = c(1,2), FUN = function(x) mean(x, rm.na = T))
plotData = data.frame(t(acceptMatrix)); colnames(plotData) =  paste(unqHts); plotData$time = tGrid
plotData$condition = rep(conditions, each = nT / 2)
nonSocialData = plotData
tGrid = c(seq(0, blockSec, by = 0.5), seq(0, blockSec, by = 0.5) + blockSec)
nT = length(tGrid)
acceptMatrix_ = array(NA, dim = c(nUnqHt,  nT, nSub))
for(sIdx in 1 : nSub){
beta_self = runif(1, 0.001, 0.01)
beta_other = beta_self
tau = runif(1, 10, 15)
iniLongRunRate = runif(1, 0.15, 1)
RLResults = RLSocial(beta_self, beta_other, tau, iniLongRunRate, htSeq_)
acceptMatrix_[, ,sIdx] = RLResults$acceptMatrixOnGrid
}
acceptMatrix = apply(acceptMatrix_, MARGIN = c(1,2), FUN = function(x) mean(x, rm.na = T))
plotData = data.frame(t(acceptMatrix)); colnames(plotData) =  paste(unqHts); plotData$time = tGrid
plotData$condition = rep(conditions, each = nT / 2)
socialData = plotData
# combine data from two conditions
aggData = rbind(gather(socialData, key = ht, value = pAccept, -time, -condition),
gather(nonSocialData, key = ht, value = pAccept, -time, -condition))
aggData$social = factor(rep(c("social", "non_social"), each = nT * nUnqHt),
levels = c("social", "non_social"))
# calculate the ideal behavior, assuming there is noise in actions
aggData$optimPAccept = 1 / (1 + exp(meanTau * (as.numeric(aggData$ht) * as.numeric(optimLongRunRate_[aggData$condition]) - rwd)))
aggData %>% mutate(ht = factor(ht, levels = unqHts)) %>%
ggplot(aes(time, pAccept, color = condition)) + geom_line(size = 1) +
scale_color_manual(values = c("red", "black")) + facet_wrap(~ht) +
geom_line(aes(time, optimPAccept), color = "#353535", linetype = "dashed") +
myTheme + xlab("Time (s)") + ylab("Percentage of accepted trials(%)") +
scale_y_continuous(limits = c(-0.1, 1.1), breaks = c(0, 0.5, 1))
aggData %>% mutate(ht = factor(ht, levels = unqHts)) %>%
ggplot(aes(time, pAccept, color = social)) + geom_line(size = 1) +
scale_color_manual(values = c("red", "black")) + facet_wrap(~ht) +
geom_line(aes(time, optimPAccept), color = "#353535", linetype = "dashed") +
myTheme + xlab("Time (s)") + ylab("Percentage of accepted trials(%)") +
scale_y_continuous(limits = c(-0.1, 1.1), breaks = c(0, 0.5, 1))
# plot differences in reward rates
# social
tGrid = c(seq(0, blockSec, by = 0.5), seq(0, blockSec, by = 0.5) + blockSec)
nT = length(tGrid)
acceptMatrix_ = array(NA, dim = c(nUnqHt,  nT, nSub))
for(sIdx in 1 : nSub){
beta_self = runif(1, 0.001, 0.01)
beta_other = beta_self * 2
tau = runif(1, 10, 15)
iniLongRunRate = runif(1, 0.15, 1)
RLResults = RLSocial(beta_self, beta_other, tau, iniLongRunRate, htSeq_)
acceptMatrix_[, ,sIdx] = RLResults$acceptMatrixOnGrid
}
acceptMatrix = apply(acceptMatrix_, MARGIN = c(1,2), FUN = function(x) mean(x, rm.na = T))
plotData = data.frame(t(acceptMatrix)); colnames(plotData) =  paste(unqHts); plotData$time = tGrid
plotData$condition = rep(conditions, each = nT / 2)
socialData = plotData
# combine data from two conditions
aggData = rbind(gather(socialData, key = ht, value = pAccept, -time, -condition),
gather(nonSocialData, key = ht, value = pAccept, -time, -condition))
aggData$social = factor(rep(c("social", "non_social"), each = nT * nUnqHt),
levels = c("social", "non_social"))
# calculate the ideal behavior, assuming there is noise in actions
aggData$optimPAccept = 1 / (1 + exp(meanTau * (as.numeric(aggData$ht) * as.numeric(optimLongRunRate_[aggData$condition]) - rwd)))
aggData %>% mutate(ht = factor(ht, levels = unqHts)) %>%
ggplot(aes(time, pAccept, color = social)) + geom_line(size = 1) +
scale_color_manual(values = c("red", "black")) + facet_wrap(~ht) +
geom_line(aes(time, optimPAccept), color = "#353535", linetype = "dashed") +
myTheme + xlab("Time (s)") + ylab("Percentage of accepted trials(%)") +
scale_y_continuous(limits = c(-0.1, 1.1), breaks = c(0, 0.5, 1))
source("RL.R")
source("RLSocial.R")
library("ggplot2")
library("dplyr")
library("tidyr")
library("lme4")
source("subFxs/plotThemes.R")
# load expParas
load("expParas.RData")
# output dir
dir.create("figures")
# simulate non_social data
beta = 0.002
tau = 2
iniLongRunRate = runif(1, 0.15, 1)
# create the ht sequence
htSeq_ = lapply(1 : nCondition, function(i) {
condition = conditions[i]
tempt = as.vector(replicate(nChunkMax, sample(hts_[[condition]], chunkSize)))
tempt[1 : nTrialMax]
})
# simulate non_social data
beta = 0.002
tau = 2
iniLongRunRate = runif(1, 0.15, 1)
RLResults = RL(beta, tau, iniLongRunRate, htSeq_)
action = ifelse(RLResults$trialEarnings == rwd)
# prepare data
action = ifelse(RLResults$trialEarnings == rwd, 1, 0)
# prepare data
action = ifelse(RLResults$trialEarnings == rwd, 1, 0)
pastEarnings1 = c(NA, head(RLResults$trialEarnings, -1))
data = data.frame(
action,
pastEarnings1,
scheduledHt = RLResults$scheduledHt
)
data = data[apply(data, MARGIN = 1, FUN = function(x) all(!is.na(x))),]
data
# summarise pAccept for different reward sizes and different past earnings
sumData = data %>%
group_by(rwd, pastEarnings1) %>% summarise(sum(action) / length(action))
colnames(sumData) = c("rwd", "pastEarnings1", "pAccept")
data = data.frame(
action,
pastEarnings1,
ht = RLResults$scheduledHt
)
data = data[apply(data, MARGIN = 1, FUN = function(x) all(!is.na(x))),]
# summarise pAccept for different reward sizes and different past earnings
sumData = data %>%
group_by(ht, pastEarnings1) %>% summarise(sum(action) / length(action))
colnames(sumData) = c("rwd", "pastEarnings1", "pAccept")
sumData
pastRwdRate = RLResults$trialEarnings / RLResults$spentHt
action = ifelse(RLResults$trialEarnings == rwd, 1, 0)
pastRwdRate = RLResults$trialEarnings / RLResults$spentHt
pastRwdRate[is.na(pastRwdRate)] = 0
pastRwdRate = c(NA, head(pastRwdRate, -1))
pastRwdRate
RLResults$trialEarnings / RLResults$spentHt
action = ifelse(RLResults$trialEarnings == rwd, 1, 0)
pastRwdRate = RLResults$trialEarnings / RLResults$spentHt
pastRwdRate[is.na(pastRwdRate)] = 0
pastRwdRate = c(NA, head(pastRwdRate, -1))
data = data.frame(
action,
pastEarnings1,
ht = RLResults$scheduledHt
)
data = data[apply(data, MARGIN = 1, FUN = function(x) all(!is.na(x))),]
# prepare data
action = ifelse(RLResults$trialEarnings == rwd, 1, 0)
pastRwdRate = RLResults$trialEarnings / RLResults$spentHt
pastRwdRate[RLResults$spentHt == 0] = 0
pastRwdRate = c(NA, head(pastRwdRate, -1))
data = data.frame(
action,
pastEarnings1,
ht = RLResults$scheduledHt
)
data = data[apply(data, MARGIN = 1, FUN = function(x) all(!is.na(x))),]
# summarise pAccept for different reward sizes and different past earnings
sumData = data %>%
group_by(ht, pastEarnings1) %>% summarise(sum(action) / length(action))
colnames(sumData) = c("rwd", "pastEarnings1", "pAccept")
colnames(sumData) = c("rwd", "pastEarnings1", "pAccept")
sumData
pastRwdRate = c(NA, head(pastRwdRate, -1))
data = data.frame(
action,
pastRwdRate,
ht = RLResults$scheduledHt
)
data = data[apply(data, MARGIN = 1, FUN = function(x) all(!is.na(x))),]
# summarise pAccept for different reward sizes and different past earnings
sumData = data %>%
group_by(ht, pastRwdRate) %>% summarise(sum(action) / length(action))
colnames(sumData) = c("rwd", "pastRwdRate", "pAccept")
sumData
# regression with reward sizes
fit1 = glm(pAccept~ht,
data = sumData, family = binomial)
summary(fit1)
# summarise pAccept for different reward sizes and different past earnings
sumData = data %>%
group_by(ht, pastRwdRate) %>% summarise(sum(action) / length(action))
colnames(sumData) = c("rwd", "pastRwdRate", "pAccept")
# regression with reward sizes
fit1 = glm(pAccept~ht,
data = sumData, family = binomial)
summary(fit1)
glm(pAccept~ht,
data = sumData, family = binomial)
# summarise pAccept for different reward sizes and different past earnings
sumData = data %>%
group_by(ht, pastRwdRate) %>% summarise(sum(action) / length(action))
colnames(sumData) = c("ht", "pastRwdRate", "pAccept")
# regression with reward sizes
fit1 = glm(pAccept~ht,
data = sumData, family = binomial)
summary(fit1)
sumData = data %>%
group_by(ht, pastRwdRate) %>% summarise(sum(action) / length(action))
colnames(sumData) = c("ht", "pastRwdRate", "pAccept")
sumData
sumData = data %>%
group_by(ht, pastRwdRate) %>% summarise(sum(action) / length(action))
colnames(sumData) = c("ht", "pastRwdRate", "pAccept")
data = data.frame(
action,
pastRwdRate,
ht = RLResults$scheduledHt,
condition = RLResults$condition
)
data = data[apply(data, MARGIN = 1, FUN = function(x) all(!is.na(x))),]
fit1 = glm(data$action ~ ht + condition,
data = data, family = binomial)
summary(fit1)
sumData = data %>%
group_by(ht, pastRwdRate, condition) %>% summarise(sum(action) / length(action))
colnames(sumData) = c("ht", "pastRwdRate", "condition", "pAccept")
sumData
sumData = data %>%
group_by(ht, condition) %>% summarise(sum(action) / length(action))
colnames(sumData) = c("ht", "condition", "pAccept")
sumData
sumData = data %>%
group_by(condition, ht) %>% summarise(sum(action) / length(action))
colnames(sumData) = c("condition", "ht", "pAccept")
sumData %>% ggplot(aes(condition, pAccept)) + geom_bar(stat = "identity")
sumData %>% ggplot(aes(ht, pAccept, color = condition)) + geom_bar(stat = "identity")
sumData %>% ggplot(aes(ht, pAccept, fill= condition)) + geom_bar(stat = "identity",position = 'dodge' )
sumData %>% ggplot(aes(ht, pAccept, fill= condition)) +
geom_bar(stat = "identity",position = 'dodge' )
#
sumData = data %>%
group_by(condition, pastRwdRate) %>% summarise(sum(action) / length(action))
colnames(sumData) = c("condition", "pastRwdRate", "pAccept")
sumData %>% ggplot(aes(pastRwdRate, pAccept, fill= condition)) +
geom_bar(stat = "identity",position = 'dodge' )
source("social_nonSocial.R")
library("dplyr")
library("tidyr")
# load expPara
load("expParas.RData")
# create the ht sequences in two conditions
htSeq_ = lapply(1 : nCondition, function(i) {
condition = conditions[i]
tempt = as.vector(replicate(nChunkMax, sample(hts_[[condition]], chunkSize)))
tempt[1 : nTrialMax]
})
# shuffle all possive rewards to generate the reward sequence
# call the function
social_nonSocial(htSeq_)
source("social_nonSocial.R")
library("dplyr")
library("tidyr")
# load expPara
load("expParas.RData")
# create the ht sequences in two conditions
htSeq_ = lapply(1 : nCondition, function(i) {
condition = conditions[i]
tempt = as.vector(replicate(nChunkMax, sample(hts_[[condition]], chunkSize)))
tempt[1 : nTrialMax]
})
source("RL.R")
source("RLSocial.R")
library("ggplot2")
library("dplyr")
library("tidyr")
source("subFxs/plotThemes.R")
# output dir
dir.create("figures")
# simulation parameters
nSub = 32
# non_social
tGrid = c(seq(0, blockSec, by = 0.5), seq(0, blockSec, by = 0.5) + blockSec)
nT = length(tGrid)
acceptMatrix_ = array(NA, dim = c(nUnqHt,  nT, nSub))
for(sIdx in 1 : nSub){
beta = runif(1, 0.001, 0.01)
tau = runif(1, 10, 15)
iniLongRunRate = runif(1, 0.15, 1)
RLResults = RL(beta, tau, iniLongRunRate, htSeq_)
acceptMatrix_[, ,sIdx] = RLResults$acceptMatrixOnGrid
}
acceptMatrix = apply(acceptMatrix_, MARGIN = c(1,2), FUN = function(x) mean(x, rm.na = T))
plotData = data.frame(t(acceptMatrix)); colnames(plotData) =  paste(unqHts); plotData$time = tGrid
plotData$condition = rep(conditions, each = nT / 2)
nonSocialData = plotData
# social
tGrid = c(seq(0, blockSec, by = 0.5), seq(0, blockSec, by = 0.5) + blockSec)
nT = length(tGrid)
acceptMatrix_ = array(NA, dim = c(nUnqHt,  nT, nSub))
for(sIdx in 1 : nSub){
beta_self = runif(1, 0.001, 0.01)
beta_other = beta_self * 2
tau = runif(1, 10, 15)
iniLongRunRate = runif(1, 0.15, 1)
RLResults = RLSocial(beta_self, beta_other, tau, iniLongRunRate, htSeq_)
acceptMatrix_[, ,sIdx] = RLResults$acceptMatrixOnGrid
}
acceptMatrix = apply(acceptMatrix_, MARGIN = c(1,2), FUN = function(x) mean(x, rm.na = T))
plotData = data.frame(t(acceptMatrix)); colnames(plotData) =  paste(unqHts); plotData$time = tGrid
plotData$condition = rep(conditions, each = nT / 2)
socialData = plotData
# combine data from two conditions
aggData = rbind(gather(socialData, key = ht, value = pAccept, -time, -condition),
gather(nonSocialData, key = ht, value = pAccept, -time, -condition))
aggData$social = factor(rep(c("social", "non_social"), each = nT * nUnqHt),
levels = c("social", "non_social"))
# calculate the ideal behavior, assuming there is noise in actions
aggData$optimPAccept = 1 / (1 + exp(meanTau * (as.numeric(aggData$ht) * as.numeric(optimLongRunRate_[aggData$condition]) - rwd)))
aggData %>% mutate(ht = factor(ht, levels = unqHts)) %>%
ggplot(aes(time, pAccept, color = social)) + geom_line(size = 1) +
scale_color_manual(values = c("red", "black")) + facet_wrap(~ht) +
geom_line(aes(time, optimPAccept), color = "#353535", linetype = "dashed") +
myTheme + xlab("Time (s)") + ylab("Percentage of accepted trials(%)") +
scale_y_continuous(limits = c(-0.1, 1.1), breaks = c(0, 0.5, 1))
# plot differences in reward rates
source("RL.R")
source("RLSocial.R")
library("ggplot2")
library("dplyr")
library("tidyr")
source("subFxs/plotThemes.R")
# output dir
dir.create("figures")
# simulation parameters
nSub = 32
# non_social
tGrid = c(seq(0, blockSec, by = 0.5), seq(0, blockSec, by = 0.5) + blockSec)
nT = length(tGrid)
acceptMatrix_ = array(NA, dim = c(nUnqHt,  nT, nSub))
for(sIdx in 1 : nSub){
beta = runif(1, 0.001, 0.01)
tau = runif(1, 10, 15)
iniLongRunRate = runif(1, 0.15, 1)
RLResults = RL(beta, tau, iniLongRunRate, htSeq_)
acceptMatrix_[, ,sIdx] = RLResults$acceptMatrixOnGrid
}
acceptMatrix = apply(acceptMatrix_, MARGIN = c(1,2), FUN = function(x) mean(x, rm.na = T))
plotData = data.frame(t(acceptMatrix)); colnames(plotData) =  paste(unqHts); plotData$time = tGrid
plotData$condition = rep(conditions, each = nT / 2)
nonSocialData = plotData
# social
tGrid = c(seq(0, blockSec, by = 0.5), seq(0, blockSec, by = 0.5) + blockSec)
nT = length(tGrid)
acceptMatrix_ = array(NA, dim = c(nUnqHt,  nT, nSub))
for(sIdx in 1 : nSub){
beta_self = runif(1, 0.001, 0.01)
beta_other = beta_self * 2
tau = runif(1, 10, 15)
iniLongRunRate = runif(1, 0.15, 1)
RLResults = RLSocial(beta_self, beta_other, tau, iniLongRunRate, htSeq_)
acceptMatrix_[, ,sIdx] = RLResults$acceptMatrixOnGrid
}
acceptMatrix = apply(acceptMatrix_, MARGIN = c(1,2), FUN = function(x) mean(x, rm.na = T))
plotData = data.frame(t(acceptMatrix)); colnames(plotData) =  paste(unqHts); plotData$time = tGrid
plotData$condition = rep(conditions, each = nT / 2)
socialData = plotData
# combine data from two conditions
aggData = rbind(gather(socialData, key = ht, value = pAccept, -time, -condition),
gather(nonSocialData, key = ht, value = pAccept, -time, -condition))
aggData$social = factor(rep(c("social", "non_social"), each = nT * nUnqHt),
levels = c("social", "non_social"))
# calculate the ideal behavior, assuming there is noise in actions
meanTau = 12.5
aggData$optimPAccept = 1 / (1 + exp(meanTau * (as.numeric(aggData$ht) * as.numeric(optimLongRunRate_[aggData$condition]) - rwd)))
aggData %>% mutate(ht = factor(ht, levels = unqHts)) %>%
ggplot(aes(time, pAccept, color = social)) + geom_line(size = 1) +
scale_color_manual(values = c("red", "black")) + facet_wrap(~ht) +
geom_line(aes(time, optimPAccept), color = "#353535", linetype = "dashed") +
myTheme + xlab("Time (s)") + ylab("Percentage of accepted trials(%)") +
scale_y_continuous(limits = c(-0.1, 1.1), breaks = c(0, 0.5, 1))
# plot differences in reward rates
